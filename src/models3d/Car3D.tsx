/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Author: Sketchfab (https://sketchfab.com/Sketchfab)
License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Source: https://sketchfab.com/3d-models/model-inspector-demo-press-i-128d863ab5c8467f80939cabe8b3fc34
Title: Model Inspector Demo (Press I)
*/

import { useRef, useState } from 'react';
import { useGLTF } from '@react-three/drei';
import { useFrame, useThree } from '@react-three/fiber';
import { a } from '@react-spring/three';
import type { Mesh, Material } from 'three';
import type { GLTF } from 'three-stdlib';

import carScene from '../assets/3d/car.glb';

type GLTFResult = GLTF & {
    nodes: {
        Object_2: Mesh;
        Object_3: Mesh;
        Object_4: Mesh;
        Object_5: Mesh;
    };
    materials: {
        Body_SG1: Material;
        Ground_SG: Material;
        Interior_SG: Material;
        Windows_SG: Material;
    };
};

interface Car3DProps {
    isRotating: boolean;
    setIsRotating: (isRotating: boolean) => void;
    setCurrentState: (state: string) => void;
}

const Car3D = (props: Car3DProps) => {
    const { isRotating, setIsRotating, setCurrentState } = props;
    const { nodes, materials } = useGLTF(carScene) as GLTFResult;
    const carRef = useRef<any>(null);
    const previousX = useRef(0);
    const previousY = useRef(0);
    const rotationSpeed = useRef(0);
    const dampingFactor = useRef(0.95);
    const [cursor, setCursor] = useState('pointer');

    const { camera, gl, viewport } = useThree();

    const handlePointerDown = (event: any) => {
        setIsRotating(true);
        setCursor('grabbing');
        const clientX = event.nativeEvent.touches ? event.nativeEvent.touches[0].clientX : event.clientX;
        const clientY = event.nativeEvent.touches ? event.nativeEvent.touches[0].clientY : event.clientY;
        previousX.current = clientX;
        previousY.current = clientY;
    };

    const handlePointerUp = (event: any) => {
        event.stopPropagation();
        setIsRotating(false);
        setCursor('pointer');

        const clientX = event.nativeEvent.touches ? event.nativeEvent.touches[0].clientX : event.clientX;
        const deltaX = (clientX - previousX.current) / viewport.width;
        if (carRef.current) {
            carRef.current.rotation.y += deltaX * 0.01 * Math.PI;
        }
        previousX.current = clientX;
    };

    const handlePointerMove = (event: any) => {
        // Chỉ xoay khi đang giữ chuột trái hoặc đang chạm (touch)
        const isMouseDown = event.nativeEvent.buttons === 1;
        const isTouch = !!event.nativeEvent.touches;

        if (!isRotating || (!isMouseDown && !isTouch)) return;

        const clientX = isTouch ? event.nativeEvent.touches[0].clientX : event.clientX;
        const deltaX = clientX - previousX.current;

        if (carRef.current) {
            carRef.current.rotation.y += deltaX * 0.01;
        }

        previousX.current = clientX;
    };

    // Hàm xác định state theo góc xoay
    const updateStateByRotation = (rotationY: number) => {
        // Đảm bảo rotationY luôn dương
        let angle = rotationY % (2 * Math.PI);
        if (angle < 0) angle += 2 * Math.PI;

        // Chia 360 độ thành 4 phần đều nhau (mỗi phần 90 độ - π/2 radian)
        if (angle < Math.PI / 2) setCurrentState('1');
        else if (angle < Math.PI) setCurrentState('2');
        else if (angle < Math.PI * 3 / 2) setCurrentState('3');
        else setCurrentState('4');
    };

    useFrame((_state, delta) => {
        if (!carRef.current) return;

        if (!isRotating) {
            rotationSpeed.current *= dampingFactor.current;

            if (Math.abs(rotationSpeed.current) < 0.001) {
                rotationSpeed.current = 0;
            }
            carRef.current.position.x += rotationSpeed.current * delta;
        }
        else {
            const rotation = carRef.current.rotation.y;
            updateStateByRotation(rotation);
        }
    });

    return (
        <a.group
            ref={carRef}
            onPointerDown={handlePointerDown}
            onPointerMove={handlePointerMove}
            onPointerUp={handlePointerUp}
            style={{ cursor: cursor } as any}
        >
            <group rotation={[-Math.PI / 2, 0, 0]} scale={0.004}>
                <mesh
                    geometry={nodes.Object_2.geometry}
                    material={materials.Body_SG1}
                />
                <mesh
                    geometry={nodes.Object_3.geometry}
                    material={materials.Ground_SG}
                />
                <mesh
                    geometry={nodes.Object_4.geometry}
                    material={materials.Interior_SG}
                />
                <mesh
                    geometry={nodes.Object_5.geometry}
                    material={materials.Windows_SG}
                />
            </group>
        </a.group>
    );
};

useGLTF.preload(carScene);
export default Car3D;

