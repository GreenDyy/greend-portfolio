/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Author: Sketchfab (https://sketchfab.com/Sketchfab)
License: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
Source: https://sketchfab.com/3d-models/model-inspector-demo-press-i-128d863ab5c8467f80939cabe8b3fc34
Title: Model Inspector Demo (Press I)
*/

import { useRef, useState, useEffect } from 'react';
import { useGLTF } from '@react-three/drei';
import { useFrame, useThree } from '@react-three/fiber';
import { a } from '@react-spring/three';
import type { Mesh, Material } from 'three';
import type { GLTF } from 'three-stdlib';

import carScene from '../assets/3d/car.glb';

type GLTFResult = GLTF & {
    nodes: {
        Object_2: Mesh;
        Object_3: Mesh;
        Object_4: Mesh;
        Object_5: Mesh;
    };
    materials: {
        Body_SG1: Material;
        Ground_SG: Material;
        Interior_SG: Material;
        Windows_SG: Material;
    };
};

interface Keys {
    ArrowLeft: boolean;
    ArrowRight: boolean;
    ArrowUp: boolean;
    ArrowDown: boolean;
}

function Car3D(props: any) {
    const { nodes, materials } = useGLTF(carScene) as GLTFResult;
    const carRef = useRef<any>(null);
    const [isDragging, setIsDragging] = useState(false);
    const lastX = useRef(0);
    const lastY = useRef(0);
    const { camera } = useThree();
    const rotationSpeed = useRef(0);
    const dampingFactor = 0.95;
    const [keys, setKeys] = useState<Keys>({
        ArrowLeft: false,
        ArrowRight: false,
        ArrowUp: false,
        ArrowDown: false
    });

    const handleKeyDown = (e: KeyboardEvent) => {
        if (e.key in keys) {
            console.log('dang kich hoat handleKeyDown: ', e.key);
            setKeys(prev => ({ ...prev, [e.key]: true }));
        }
    };

    const handleKeyUp = (e: KeyboardEvent) => {
        if (e.key in keys) {
            console.log('dang kich hoat handleKeyUp: ', e.key);
            setKeys(prev => ({ ...prev, [e.key]: false }));
        }
    };

    useFrame((_state, _delta) => {
        if (carRef.current) {
            if (!isDragging) {
                // Áp dụng hiệu ứng quay tiếp tục
                carRef.current.rotation.y += rotationSpeed.current;
                // Giảm dần tốc độ quay
                rotationSpeed.current *= dampingFactor;
                // Dừng quay khi tốc độ quá nhỏ
                if (Math.abs(rotationSpeed.current) < 0.001) {
                    rotationSpeed.current = 0;
                }
            }

            // Xử lý điều khiển bằng phím
            if (keys.ArrowLeft) {
                carRef.current.rotation.y += 0.02;
            }
            if (keys.ArrowRight) {
                carRef.current.rotation.y -= 0.02;
            }
            if (keys.ArrowUp) {
                carRef.current.rotation.x += 0.02;
            }
            if (keys.ArrowDown) {
                carRef.current.rotation.x -= 0.02;
            }
        }
    });

    const handlePointerDown = (event: PointerEvent | TouchEvent) => {
        setIsDragging(true);
        const clientX = 'touches' in event ? event.touches[0].clientX : event.clientX;
        const clientY = 'touches' in event ? event.touches[0].clientY : event.clientY;
        lastX.current = clientX;
        lastY.current = clientY;
        // Reset rotation speed khi bắt đầu kéo mới
        rotationSpeed.current = 0;
    };

    const handlePointerMove = (event: PointerEvent | TouchEvent) => {
        if (!isDragging) return;

        const clientX = 'touches' in event ? event.touches[0].clientX : event.clientX;
        const clientY = 'touches' in event ? event.touches[0].clientY : event.clientY;
        const deltaX = clientX - lastX.current;
        const deltaY = clientY - lastY.current;

        if (carRef.current) {
            carRef.current.rotation.y += deltaX * 0.01;
            carRef.current.rotation.x += deltaY * 0.01;
            // Cập nhật rotation speed dựa trên tốc độ kéo
            rotationSpeed.current = deltaX * 0.01;
        }

        lastX.current = clientX;
        lastY.current = clientY;
    };

    const handlePointerUp = (e: PointerEvent) => {
        setIsDragging(false);
        e.stopPropagation();
    };

    useEffect(() => {
        const handlePointerDownWrapper = (e: Event) => handlePointerDown(e as PointerEvent | TouchEvent);
        const handlePointerMoveWrapper = (e: Event) => handlePointerMove(e as PointerEvent | TouchEvent);
        const handlePointerUpWrapper = (e: Event) => handlePointerUp(e as PointerEvent);

        document.addEventListener('pointerdown', handlePointerDownWrapper);
        document.addEventListener('pointermove', handlePointerMoveWrapper);
        document.addEventListener('pointerup', handlePointerUpWrapper);
        document.addEventListener('keydown', handleKeyDown);
        document.addEventListener('keyup', handleKeyUp);
        return () => {
            document.removeEventListener('pointerdown', handlePointerDownWrapper);
            document.removeEventListener('pointermove', handlePointerMoveWrapper);
            document.removeEventListener('pointerup', handlePointerUpWrapper);
            document.removeEventListener('keydown', handleKeyDown);
            document.removeEventListener('keyup', handleKeyUp);
        };
    }, [isDragging]);

    return (
        <a.group
            ref={carRef}
            {...props}
            style={{ cursor: 'pointer' } as any}
        >
            <group rotation={[-Math.PI / 2, 0, 0]} scale={0.004}>
                <mesh
                    geometry={nodes.Object_2.geometry}
                    material={materials.Body_SG1}
                />
                <mesh
                    geometry={nodes.Object_3.geometry}
                    material={materials.Ground_SG}
                />
                <mesh
                    geometry={nodes.Object_4.geometry}
                    material={materials.Interior_SG}
                />
                <mesh
                    geometry={nodes.Object_5.geometry}
                    material={materials.Windows_SG}
                />
            </group>
        </a.group>
    );
}

useGLTF.preload('/car.glb');
export default Car3D;

